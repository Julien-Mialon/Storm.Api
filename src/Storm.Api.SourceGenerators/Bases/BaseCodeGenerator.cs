using Microsoft.CodeAnalysis;

namespace Storm.Api.SourceGenerators.Bases;

public abstract class BaseCodeGenerator : IIncrementalGenerator
{
	protected string GeneratedCodeAttribute { get; set; }

	protected virtual List<AttributeDefinition> Attributes => [];

	protected BaseCodeGenerator()
	{
		GeneratedCodeAttribute = $"[GeneratedCode(\"{GetType().FullName}\", \"1.0.0\")]";
	}

	public virtual void Initialize(IncrementalGeneratorInitializationContext context)
	{
		if (Attributes.Count > 0)
		{
			context.RegisterPostInitializationOutput(CreateAttributes);
		}
	}

	private void CreateAttributes(IncrementalGeneratorPostInitializationContext context)
	{
		foreach (AttributeDefinition attribute in Attributes)
		{
			CreateAttribute(context, attribute);
		}
	}

	private void CreateAttribute(IncrementalGeneratorPostInitializationContext context, AttributeDefinition definition)
	{
		CodeBuilder builder = new();
		builder.AddLine($"// <auto-generated />");
		builder.AddLine("#nullable enable");
		builder.AddLine($"using System;");
		builder.AddLine($"using System.CodeDom.Compiler;");
		builder.AddLine();
		builder.AddLine($"namespace {definition.Namespace};");
		builder.AddLine();
		builder.AddLine(GeneratedCodeAttribute);
		builder.AddLine($"[AttributeUsage(AttributeTargets.{definition.Targets:G}, Inherited = {definition.Inherited.ToString().ToLowerInvariant()}, AllowMultiple = {definition.AllowMultiple.ToString().ToLowerInvariant()})]");
		builder.Add($"internal sealed class {definition.FullName}");
		if (definition.Generics.Count > 0)
		{
			builder.Add($"<{string.Join(", ", definition.Generics.Select(x => x.Name))}>");
		}

		builder.Add(" : Attribute");
		if (definition.Generics.Count > 0)
		{
			List<(string name, GenericConstraintDefinition constraints)> constraints = definition.Generics
				.Where(x => x.Constraints is not null
				            && (x.Constraints.IsClass
				                || x.Constraints.IsStruct
				                || x.Constraints.HasNew
				                || x.Constraints.TypeConstraints.Count > 0))
				.Select(x => (name: x.Name, constraints: x.Constraints!))
				.ToList();

			foreach ((string name, GenericConstraintDefinition constraint) in constraints)
			{
				builder.AddLine().Add($"where {name} : ");
				if (constraint.IsClass)
				{
					builder.Add("class");
					if (constraint.HasNew)
					{
						builder.Add(", new()");
					}
				}
				else if (constraint.IsStruct)
				{
					builder.Add("struct");
				}
				else if (constraint.TypeConstraints.Count > 0)
				{
					if (constraint.HasNew)
					{
						builder.Add("new(), ");
					}

					builder.Add(string.Join(", ", constraint.TypeConstraints));
				}
			}
		}

		if (definition.Properties.Count == 0)
		{
			builder.AddLine(";");
		}
		else
		{
			builder.AddLine().AddLine("{").Indent();

			List<AttributePropertyDefinition> constructorProperties = [];
			foreach (AttributePropertyDefinition property in definition.Properties)
			{
				builder.AddLine($"public {property.Type.FullName} {property.Name} {{ get; set; }}")
					.AddLine();

				if (property.InConstructor)
				{
					constructorProperties.Add(property);
				}
			}

			if (constructorProperties.Count > 0)
			{
				builder.AddLine($"public {definition.FullName}({string.Join(", ", constructorProperties.Select(x => $"{x.Type.FullName} {x.ConstructorArgumentName}"))})")
					.AddLine("{")
					.Indent();

				foreach (AttributePropertyDefinition property in constructorProperties)
				{
					builder.AddLine($"{property.Name} = {property.ConstructorArgumentName};");
				}

				builder.Unindent().AddLine("}");
			}

			builder.Unindent().AddLine("}");
		}

		string code = builder.Code();

		context.AddSource($"{definition.MetadataName}.g.cs", code);
	}

	protected void GenerateDiagnostics(SourceProductionContext sourceContext, DiagnosticContext context)
	{
		foreach (DiagnosticItemContext item in context.Items)
		{
			sourceContext.ReportDiagnostic(Diagnostic.Create(new(item.Id, item.Title, item.MessageFormat, item.Category, item.Severity, true), item.Location));
		}
	}
}